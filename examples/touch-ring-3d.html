<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Touch Ring - Interactive</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            color: #e8e8e8;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
            overflow: hidden;
            touch-action: none;
        }

        #canvas-container {
            position: fixed;
            inset: 0;
            cursor: grab;
        }

        #canvas-container.dragging {
            cursor: grabbing;
        }

        .ui-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 10;
        }

        .header {
            position: absolute;
            top: 3rem;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
        }

        .title {
            font-size: clamp(2rem, 5vw, 3.5rem);
            font-weight: 200;
            letter-spacing: -0.02em;
            margin-bottom: 0.5rem;
            opacity: 0.9;
        }

        .subtitle {
            font-size: 0.85rem;
            color: #555;
            letter-spacing: 0.15em;
            text-transform: uppercase;
        }

        .center-info {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 0;
            transition: opacity 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .center-info.show {
            opacity: 1;
        }

        .center-time {
            font-size: 4rem;
            font-weight: 200;
            letter-spacing: -0.03em;
            margin-bottom: 0.5rem;
        }

        .center-event {
            font-size: 1rem;
            color: #888;
            letter-spacing: 0.05em;
        }

        .instructions {
            position: absolute;
            bottom: 3rem;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            color: #555;
            font-size: 0.8rem;
            letter-spacing: 0.1em;
            text-transform: uppercase;
        }

        /* Event labels around ring */
        .event-label {
            position: absolute;
            padding: 0.5rem 1rem;
            background: rgba(255, 255, 255, 0.02);
            border: 1px solid rgba(255, 255, 255, 0.06);
            border-radius: 20px;
            font-size: 0.75rem;
            letter-spacing: 0.05em;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: none;
            backdrop-filter: blur(10px);
        }

        .event-label.active {
            background: rgba(59, 130, 246, 0.15);
            border-color: rgba(59, 130, 246, 0.4);
            transform: scale(1.1);
        }

        .event-time {
            color: #666;
            font-size: 0.65rem;
            margin-bottom: 0.2rem;
        }

        .event-title {
            color: #e8e8e8;
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <div class="ui-overlay">
        <div class="header">
            <h1 class="title">40 Hours with Caspar</h1>
            <p class="subtitle">Touch & Rotate</p>
        </div>

        <div class="center-info" id="centerInfo">
            <div class="center-time" id="centerTime">20:00</div>
            <div class="center-event" id="centerEvent">Bowling</div>
        </div>

        <div class="instructions">Drag to explore events</div>
    </div>

    <!-- Three.js + GSAP -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        const events = [
            { time: '20:00', title: 'Bowling', color: 0x3b82f6 },
            { time: '22:30', title: 'Oldtimer', color: 0x8b5cf6 },
            { time: '11:30', title: 'Brunch', color: 0xec4899 },
            { time: '14:00', title: 'Art Walk', color: 0xf59e0b },
            { time: '19:00', title: 'Workout', color: 0x10b981 },
            { time: '20:30', title: 'Dinner', color: 0x3b82f6 },
            { time: '23:00', title: 'Drinks', color: 0x8b5cf6 }
        ];

        // Scene setup
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 8;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        container.appendChild(renderer.domElement);

        // Main ring
        const ringGeometry = new THREE.TorusGeometry(3, 0.08, 32, 100);
        const ringMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            metalness: 0.8,
            roughness: 0.2,
            emissive: 0x0a0a0a
        });
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        scene.add(ring);

        // Time segments (inner glow ring)
        const segments = [];
        const segmentAngle = (Math.PI * 2) / events.length;

        events.forEach((event, i) => {
            const startAngle = i * segmentAngle;
            const endAngle = (i + 1) * segmentAngle;

            const segmentGeometry = new THREE.TorusGeometry(
                2.7, 0.15, 16, 32, endAngle - startAngle
            );
            const segmentMaterial = new THREE.MeshStandardMaterial({
                color: event.color,
                emissive: event.color,
                emissiveIntensity: 0,
                transparent: true,
                opacity: 0.3,
                metalness: 0.5,
                roughness: 0.3
            });

            const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
            segment.rotation.z = startAngle;
            segment.userData = { index: i, active: false };

            segments.push(segment);
            scene.add(segment);
        });

        // Event markers on ring
        const markers = [];
        events.forEach((event, i) => {
            const angle = (i / events.length) * Math.PI * 2;
            const markerGeometry = new THREE.SphereGeometry(0.12, 32, 32);
            const markerMaterial = new THREE.MeshStandardMaterial({
                color: event.color,
                emissive: event.color,
                emissiveIntensity: 0.3,
                metalness: 0.7,
                roughness: 0.3
            });

            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.x = Math.cos(angle) * 3;
            marker.position.y = Math.sin(angle) * 3;
            marker.userData = { index: i, event };

            markers.push(marker);
            scene.add(marker);
        });

        // Lighting
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 1, 100);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);

        const fillLight = new THREE.PointLight(0x3b82f6, 0.5, 100);
        fillLight.position.set(-5, -5, 3);
        scene.add(fillLight);

        // Interaction
        let isDragging = false;
        let previousMouseX = 0;
        let rotationVelocity = 0;
        let targetRotation = 0;
        let currentActive = null;

        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        function onPointerDown(e) {
            isDragging = true;
            container.classList.add('dragging');
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            previousMouseX = clientX;
            rotationVelocity = 0;
        }

        function onPointerMove(e) {
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            // Update mouse for raycasting
            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;

            if (isDragging) {
                const deltaX = clientX - previousMouseX;
                rotationVelocity = deltaX * 0.01;
                targetRotation += rotationVelocity;
                previousMouseX = clientX;
            }
        }

        function onPointerUp() {
            isDragging = false;
            container.classList.remove('dragging');
        }

        // Check for marker hover/touch
        function checkIntersections() {
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(markers);

            if (intersects.length > 0) {
                const index = intersects[0].object.userData.index;
                activateEvent(index);
            } else if (!isDragging) {
                deactivateEvent();
            }
        }

        function activateEvent(index) {
            if (currentActive === index) return;

            // Deactivate previous
            if (currentActive !== null) {
                gsap.to(segments[currentActive].material, {
                    emissiveIntensity: 0,
                    duration: 0.5
                });
                gsap.to(markers[currentActive].scale, {
                    x: 1, y: 1, z: 1,
                    duration: 0.4,
                    ease: 'power2.out'
                });
            }

            currentActive = index;

            // Activate segment
            gsap.to(segments[index].material, {
                emissiveIntensity: 0.8,
                duration: 0.6,
                ease: 'power2.out'
            });

            // Scale marker
            gsap.to(markers[index].scale, {
                x: 1.4, y: 1.4, z: 1.4,
                duration: 0.5,
                ease: 'elastic.out(1, 0.5)'
            });

            // Update center info
            document.getElementById('centerTime').textContent = events[index].time;
            document.getElementById('centerEvent').textContent = events[index].title;
            document.getElementById('centerInfo').classList.add('show');

            // Haptic
            if (navigator.vibrate) navigator.vibrate(10);
        }

        function deactivateEvent() {
            if (currentActive === null) return;

            gsap.to(segments[currentActive].material, {
                emissiveIntensity: 0,
                duration: 0.5
            });

            gsap.to(markers[currentActive].scale, {
                x: 1, y: 1, z: 1,
                duration: 0.4,
                ease: 'power2.out'
            });

            document.getElementById('centerInfo').classList.remove('show');
            currentActive = null;
        }

        // Event listeners
        container.addEventListener('mousedown', onPointerDown);
        container.addEventListener('mousemove', onPointerMove);
        container.addEventListener('mouseup', onPointerUp);
        container.addEventListener('touchstart', onPointerDown, { passive: true });
        container.addEventListener('touchmove', onPointerMove, { passive: true });
        container.addEventListener('touchend', onPointerUp);

        // Animation loop
        function animate() {
            requestAnimationFrame(animate);

            // Smooth rotation with momentum
            if (!isDragging) {
                rotationVelocity *= 0.95; // Deceleration
            }

            ring.rotation.z += rotationVelocity;

            segments.forEach(segment => {
                segment.rotation.z += rotationVelocity;
            });

            markers.forEach(marker => {
                const currentAngle = Math.atan2(marker.position.y, marker.position.x);
                const newAngle = currentAngle + rotationVelocity;
                marker.position.x = Math.cos(newAngle) * 3;
                marker.position.y = Math.sin(newAngle) * 3;
            });

            // Check intersections
            if (!isDragging) {
                checkIntersections();
            }

            // Subtle ring pulse
            ring.scale.setScalar(1 + Math.sin(Date.now() * 0.001) * 0.01);

            renderer.render(scene, camera);
        }

        // Handle resize
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Start
        animate();

        // Prevent context menu
        document.addEventListener('contextmenu', e => e.preventDefault());
    </script>
</body>
</html>
