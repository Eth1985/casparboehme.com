<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>40 Hours with Caspar</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800;900&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #0a0a0a;
            color: #e8e8e8;
            font-family: -apple-system, BlinkMacSystemFont, 'SF Pro Display', sans-serif;
            overflow: hidden;
            touch-action: none;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            transition: background 0.8s ease;
        }

        /* Background image for Gem√§ldegalerie event */
        body.sculpture-active {
            background: #0a0a0a url('/sculpture.jpg') center/cover;
            background-blend-mode: multiply;
        }

        body.sculpture-active::before {
            content: '';
            position: fixed;
            inset: 0;
            background: rgba(10, 10, 10, 0.6);
            pointer-events: none;
            z-index: 1;
        }



        #canvas-container {
            position: fixed;
            inset: 0;
            cursor: grab;
            z-index: 2;
        }

        #canvas-container.dragging {
            cursor: grabbing;
        }

        .ui-overlay {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 10;
        }

        /* Dark overlay for ring center - improves text readability */
        .ring-overlay {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 40vmin;
            height: 40vmin;
            border-radius: 50%;
            background: radial-gradient(circle, rgba(10, 10, 10, 0.92) 0%, rgba(10, 10, 10, 0.85) 50%, transparent 70%);
            pointer-events: none;
            z-index: 2;
            transition: background 0.5s ease;
        }

        /* Stronger overlay for brunch to ensure text readability */
        .ring-overlay.brunch-active {
            background: radial-gradient(circle, rgba(10, 10, 10, 0.95) 0%, rgba(10, 10, 10, 0.92) 50%, rgba(10, 10, 10, 0.3) 70%);
        }

        @media (max-width: 768px) {
            .ring-overlay {
                width: 50vmin;
                height: 50vmin;
            }
        }

        /* Kiss emoji particles */
        .kiss-emoji {
            position: fixed;
            font-size: 3rem;
            pointer-events: none;
            z-index: 15;
            animation: kiss-float 3s ease-out forwards;
            user-select: none;
        }

        @keyframes kiss-float {
            0% {
                opacity: 0;
                transform: translate(0, 0) scale(0.5) rotate(0deg);
            }
            10% {
                opacity: 1;
            }
            70% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: translate(var(--tx), var(--ty)) scale(1.5) rotate(var(--rotate));
            }
        }

        /* Chinese emoji particles */
        .chinese-emoji {
            position: fixed;
            font-size: 3rem;
            pointer-events: none;
            z-index: 15;
            animation: chinese-float 3s ease-out forwards;
            user-select: none;
        }

        @keyframes chinese-float {
            0% {
                opacity: 0;
                transform: translate(0, 0) scale(0.5) rotate(0deg);
            }
            10% {
                opacity: 1;
            }
            70% {
                opacity: 1;
            }
            100% {
                opacity: 0;
                transform: translate(var(--tx), var(--ty)) scale(1.5) rotate(var(--rotate));
            }
        }

        /* Header with sophisticated animation */
        .header {
            position: absolute;
            top: 6vh;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            width: 90%;
            z-index: 5;
            display: none; /* Hidden for now */
        }

        .title {
            font-size: clamp(1.4rem, 5vw, 2.8rem);
            font-weight: 600;
            letter-spacing: -0.02em;
            line-height: 1.05;
            color: #f5f5f7;
        }

        @media (max-width: 768px) {
            .title {
                font-size: clamp(1.1rem, 5.5vw, 1.8rem);
            }
        }

        /* Center Event Info */
        .center-info {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            opacity: 0;
            pointer-events: none;
            max-width: 85vw;
            z-index: 10;
        }

        .center-info.show {
            opacity: 1;
            pointer-events: auto;
        }

        .center-event {
            font-size: clamp(0.75rem, 2.2vw, 0.9rem);
            color: #86868b;
            letter-spacing: 0.01em;
            margin-bottom: 0.6rem;
            font-weight: 500;
            line-height: 1.3;
        }

        .center-date {
            font-size: clamp(0.65rem, 1.8vw, 0.75rem);
            color: #6e6e73;
            letter-spacing: 0.02em;
            margin-bottom: 0.8rem;
            font-weight: 400;
            text-transform: uppercase;
        }

        .center-time {
            font-size: clamp(2.2rem, 9vw, 3.5rem);
            font-weight: 300;
            letter-spacing: -0.02em;
            margin-bottom: 0.4rem;
            line-height: 1;
            color: #f5f5f7;
        }

        .center-location {
            font-size: clamp(0.75rem, 2vw, 0.85rem);
            color: #86868b;
            letter-spacing: 0.01em;
            margin-bottom: 1.8rem;
            font-weight: 400;
        }


        /* Monochrome RSVP Button */
        .rsvp-button {
            display: inline-block;
            padding: clamp(0.8rem, 3vw, 1rem) clamp(2rem, 8vw, 3rem);
            background: transparent;
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: 50px;
            color: #e8e8e8;
            font-size: clamp(0.75rem, 2.5vw, 0.9rem);
            letter-spacing: 0.15em;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            pointer-events: auto;
            backdrop-filter: blur(10px);
            font-weight: 300;
        }

        .rsvp-button:hover,
        .rsvp-button:active {
            background: rgba(255, 255, 255, 0.03);
            border-color: rgba(255, 255, 255, 0.3);
            transform: translateY(-1px);
        }

        /* RSVP Modal - Brutalist Style */
        .rsvp-modal {
            position: fixed;
            inset: 0;
            z-index: 100;
            display: flex;
            align-items: center;
            justify-content: center;
            opacity: 0;
            pointer-events: none;
            background: #0a0a0a;
        }

        .rsvp-modal.show {
            opacity: 1;
            pointer-events: auto;
        }

        .rsvp-content {
            max-width: 600px;
            width: 90vw;
            text-align: left;
            position: relative;
            padding: 40px 20px;
            background: #0a0a0a;
            border-radius: 0 !important;
        }

        .rsvp-event-title {
            font-family: 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif;
            font-size: clamp(48px, 10vw, 100px);
            font-weight: 900;
            margin-bottom: 60px;
            letter-spacing: -0.02em;
            color: #FFFFFF;
            line-height: 0.95;
            position: relative;
            z-index: 1;
        }

        .rsvp-event-time {
            font-family: 'Courier New', 'Courier', monospace;
            font-size: 18px;
            color: #FFFFFF;
            margin-bottom: 80px;
            line-height: 1.6;
            border-left: 2px solid #FFFFFF;
            padding-left: 20px;
            position: relative;
            z-index: 1;
        }

        .rsvp-form {
            margin-bottom: 40px;
        }

        .rsvp-input {
            width: 100%;
            padding: 12px 0;
            background: transparent;
            border: none;
            border-bottom: 2px solid #FFFFFF;
            border-radius: 0 !important;
            color: #FFFFFF;
            font-size: 18px;
            font-family: 'Courier New', 'Courier', monospace;
            margin-bottom: 40px;
            transition: none;
            position: relative;
            z-index: 1;
        }

        .rsvp-input:focus {
            outline: none;
            border-bottom-color: #FFFFFF;
        }

        .rsvp-input::placeholder {
            color: #666666;
            text-transform: uppercase;
            font-size: 14px;
            letter-spacing: 0.05em;
        }

        .rsvp-buttons {
            display: flex;
            gap: 0;
            justify-content: center;
        }

        .rsvp-submit {
            width: 100%;
            padding: 20px;
            border: none;
            border-radius: 0 !important;
            font-size: 18px;
            letter-spacing: 0.1em;
            text-transform: uppercase;
            cursor: pointer;
            transition: opacity 0.2s;
            font-family: 'Courier New', 'Courier', monospace;
            font-weight: bold;
            position: relative;
            z-index: 1;
            background: #FFFFFF;
            color: #000000;
            margin-bottom: 40px;
        }

        .rsvp-submit:hover {
            opacity: 0.9;
        }

        .rsvp-submit:active {
            transform: scale(0.98);
        }

        /* Calendar buttons */
        .rsvp-calendar {
            width: 100%;
            padding: 16px;
            background: transparent;
            border: 1px solid #FFFFFF;
            border-radius: 0 !important;
            color: #FFFFFF;
            font-size: 12px;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.2s;
            font-family: 'Courier New', 'Courier', monospace;
            font-weight: bold;
            text-transform: uppercase;
            position: relative;
            z-index: 1;
            display: block;
        }

        .rsvp-calendar:hover {
            background: #FFFFFF;
            color: #000000;
        }

        .rsvp-calendar:active {
            transform: scale(0.98);
        }

        /* Mobile optimizations */
        @media (max-width: 768px) {
            .rsvp-content {
                padding: 20px 16px;
            }

            .rsvp-event-title {
                font-size: clamp(48px, 10vw, 64px);
                margin-bottom: 40px;
            }

            .rsvp-event-time {
                font-size: 16px;
                margin-bottom: 60px;
            }

            .rsvp-input {
                font-size: 16px;
            }

            .rsvp-submit {
                font-size: 16px;
                padding: 18px;
            }

            .rsvp-calendar {
                font-size: 11px;
                padding: 14px;
            }
        }

        @media (max-width: 768px) {
            .header {
                top: 8vh;
            }

            .center-time {
                margin-bottom: 0.5rem;
            }

            .center-duration {
                margin-bottom: 1.5rem;
            }

            .rsvp-buttons {
                flex-direction: column;
            }

            .rsvp-submit, .rsvp-close {
                width: 100%;
            }
        }

        @media (max-width: 480px) {
            .header {
                top: 6vh;
            }
        }

        @media (max-height: 700px) {
            .header {
                top: 5vh;
            }
        }

        @media (max-height: 600px) {
            .header {
                top: 3vh;
            }
        }
    </style>
</head>
<body>
    <div id="canvas-container"></div>

    <!-- Dark overlay for better text readability inside ring -->
    <div class="ring-overlay"></div>


    <div class="ui-overlay">
        <div class="header">
            <h1 class="title" id="mainTitle">40 Hours Caspar</h1>
        </div>

        <div class="center-info" id="centerInfo">
            <div class="center-event" id="centerEvent">Bowling</div>
            <div class="center-date" id="centerDate">November 12</div>
            <div class="center-time" id="centerTime">20:00</div>
            <div class="center-location" id="centerLocation">Berolina</div>
            <button class="rsvp-button" id="rsvpButton">RSVP</button>
        </div>
    </div>

    <!-- RSVP Modal -->
    <div class="rsvp-modal" id="rsvpModal">
        <div class="rsvp-content">
            <h2 class="rsvp-event-title" id="modalEventTitle">Bowling</h2>
            <div class="rsvp-event-time" id="modalEventTime">November 12<br>20:00<br>Berolina</div>

            <form class="rsvp-form" id="rsvpForm">
                <input type="text" class="rsvp-input" placeholder="YOUR NAME" required id="rsvpName" autocomplete="name">
                <input type="text" class="rsvp-input" placeholder="PLUS ONES (OPTIONAL)" id="rsvpPlusOnes" autocomplete="off">
            </form>

            <div class="rsvp-buttons">
                <button class="rsvp-submit" id="rsvpSubmit">I'M COMING</button>
            </div>

            <div style="border-top: 1px solid #FFFFFF; padding-top: 40px; margin-bottom: 0;">
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                    <button class="rsvp-calendar" id="addToGoogleCal">+ GOOGLE</button>
                    <button class="rsvp-calendar" id="addToAppleCal">+ APPLE</button>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        // Check if post-processing loaded
        window.addEventListener('load', () => {
            console.log('EffectComposer:', typeof THREE.EffectComposer);
            console.log('UnrealBloomPass:', typeof THREE.UnrealBloomPass);
        });
    </script>

    <script>
        const events = [
            { date: 'November 12', time: '20:00', endTime: '22:00', title: 'Bowling', location: 'Berolina', address: 'Berolina, Kleiststra√üe 3-6, 10787 Berlin', color: 0x666666 },
            { date: 'November 12', time: '22:30', endTime: '23:59', title: 'rein feiern', location: 'New Oldtimer', address: 'Lietzenburger Str. 12, 10789 Berlin', color: 0x666666 },
            { date: 'November 13', time: '11:30', endTime: '14:00', title: 'Brunch', location: 'Cafe Einstein Mommseneck', address: 'Cafe Einstein Mommseneck, Mommsenstra√üe 45, 10629 Berlin', color: 0x666666 },
            { date: 'November 13', time: '14:00', endTime: '18:00', title: 'Walk & Gem√§ldegalerie', location: 'Gem√§ldegalerie', address: 'Matth√§ikirchplatz, 10785 Berlin', color: 0x666666 },
            { date: 'November 13', time: '19:00', endTime: '20:00', title: 'Workout', location: 'ride.bln Charlottenburg', address: 'ride.bln Charlottenburg, Lietzenburger Stra√üe 86, Berlin', color: 0x666666 },
            { date: 'November 13', time: '20:30', endTime: '22:30', title: 'Dinner', location: 'Ming Dynastie', address: 'Ming Dynastie Europa Center, Tauentzienstra√üe 9-12, 10789 Berlin', color: 0x666666 },
            { date: 'November 13', time: '23:00', endTime: '01:00', title: 'Drinks', location: 'Victoria Bar', address: 'Victoria Bar, Potsdamer Stra√üe 102, 10785 Berlin', color: 0x666666 }
        ];

        // Scene setup

        // Scene setup - PROPER responsive sizing that works on ANY device
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();

        // Calculate available space for ring - different for mobile vs desktop
        function calculateRingSize() {
            const vw = window.innerWidth;
            const vh = window.innerHeight;
            const isMobile = vw < 768;

            let headerSpace, bottomMargin, sideMargin, ringScale;

            if (isMobile) {
                // Mobile: move ring down, make room for title at top
                headerSpace = vh * 0.22; // More space at top for title
                bottomMargin = vh * 0.10; // Less space at bottom (ring moves down)
                sideMargin = vw * 0.08;
                ringScale = 0.90; // Fill 90% of available space
            } else {
                // Desktop: smaller ring, centered nicely
                headerSpace = vh * 0.25;
                bottomMargin = vh * 0.15;
                sideMargin = vw * 0.20; // More side margins on desktop
                ringScale = 0.65; // Smaller on desktop (65% of space)
            }

            // Available space for ring
            const availableHeight = vh - headerSpace - bottomMargin;
            const availableWidth = vw - (sideMargin * 2);

            // Ring should fit in the smaller dimension
            const maxDiameter = Math.min(availableHeight, availableWidth) * ringScale;

            // Convert to Three.js units
            const ringRadiusInUnits = 2.5;
            const cameraDistance = ringRadiusInUnits / Math.tan((50 * Math.PI / 180) / 2) * (600 / maxDiameter);

            return {
                radius: ringRadiusInUnits,
                cameraZ: cameraDistance,
                isMobile: isMobile
            };
        }

        const ringSize = calculateRingSize();
        const ringRadius = ringSize.radius;

        const camera = new THREE.PerspectiveCamera(
            50, // Fixed FOV for consistent perspective
            window.innerWidth / window.innerHeight,
            0.1,
            1000
        );
        camera.position.z = ringSize.cameraZ;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        container.appendChild(renderer.domElement);

        // Main ring - smaller, fits screen
        const ringGeometry = new THREE.TorusGeometry(ringRadius, 0.04, 32, 100);
        const ringMaterial = new THREE.MeshStandardMaterial({
            color: 0x1a1a1a,
            metalness: 0.7,
            roughness: 0.3,
            emissive: 0x0a0a0a
        });
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        scene.add(ring);

        // Time segments - touchable slices
        const segments = [];
        const segmentAngle = (Math.PI * 2) / events.length;

        events.forEach((event, i) => {
            // Position segments clockwise starting from top (12 o'clock position)
            const startAngle = Math.PI / 2 - i * segmentAngle;
            const endAngle = Math.PI / 2 - (i + 1) * segmentAngle;

            const segmentGeometry = new THREE.TorusGeometry(
                ringRadius - 0.3, 0.12, 16, 32, segmentAngle
            );
            const segmentMaterial = new THREE.MeshStandardMaterial({
                color: 0x888888,
                emissive: 0x888888,
                emissiveIntensity: 0,
                transparent: true,
                opacity: 0.3,
                metalness: 0.5,
                roughness: 0.4
            });

            const segment = new THREE.Mesh(segmentGeometry, segmentMaterial);
            segment.rotation.z = startAngle;
            segment.userData = { index: i, event, isSegment: true };

            segments.push(segment);
            scene.add(segment);
        });

        // Event markers - larger hit area for better touch detection
        const markers = [];
        events.forEach((event, i) => {
            // Position events clockwise starting from top (12 o'clock position)
            const angle = Math.PI / 2 - (i / events.length) * Math.PI * 2;

            // Visible sphere
            const markerGeometry = new THREE.SphereGeometry(0.12, 32, 32);
            const markerMaterial = new THREE.MeshStandardMaterial({
                color: 0x888888,
                emissive: 0x666666,
                emissiveIntensity: 0.2,
                metalness: 0.8,
                roughness: 0.2
            });

            const marker = new THREE.Mesh(markerGeometry, markerMaterial);
            marker.position.x = Math.cos(angle) * ringRadius;
            marker.position.y = Math.sin(angle) * ringRadius;
            marker.userData = { index: i, event };

            // Add invisible larger hit area for easier touching
            const hitAreaGeometry = new THREE.SphereGeometry(0.3, 16, 16);
            const hitAreaMaterial = new THREE.MeshBasicMaterial({
                visible: false
            });
            const hitArea = new THREE.Mesh(hitAreaGeometry, hitAreaMaterial);
            hitArea.userData = { index: i, event };
            marker.add(hitArea);

            markers.push(marker);
            scene.add(marker);
        });

        // Lighting - softer for mobile
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xffffff, 0.8, 100);
        pointLight.position.set(5, 5, 5);
        scene.add(pointLight);

        const fillLight = new THREE.PointLight(0xffffff, 0.3, 100);
        fillLight.position.set(-5, -5, 3);
        scene.add(fillLight);

        // ========== CINEMA 4D QUALITY FIRE SYSTEM ==========

        // Post-processing setup with bloom
        let composer, bloomPass;

        function setupPostProcessing() {
            if (typeof THREE.EffectComposer === 'undefined') {
                console.error('EffectComposer not loaded');
                return false;
            }

            composer = new THREE.EffectComposer(renderer);

            const renderPass = new THREE.RenderPass(scene, camera);
            composer.addPass(renderPass);

            bloomPass = new THREE.UnrealBloomPass(
                new THREE.Vector2(window.innerWidth, window.innerHeight),
                2.5,    // strength - high for Cinema 4D glow
                0.8,    // radius
                0.2     // threshold - lower for more glow
            );
            composer.addPass(bloomPass);

            console.log('‚úÖ Post-processing setup complete');
            return true;
        }

        // CINEMA 4D QUALITY FIRE SHADER
        const fireShaderCode = {
            vertexShader: `
                varying vec3 vPosition;
                varying vec3 vWorldPosition;
                varying vec2 vUv;

                void main() {
                    vPosition = position;
                    vWorldPosition = (modelMatrix * vec4(position, 1.0)).xyz;
                    vUv = uv;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,

            fragmentShader: `
                uniform float time;
                uniform float intensity;
                varying vec3 vPosition;
                varying vec3 vWorldPosition;
                varying vec2 vUv;

                // 3D Perlin noise (simplex)
                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }

                float snoise(vec3 v) {
                    const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);

                    vec3 i  = floor(v + dot(v, C.yyy));
                    vec3 x0 = v - i + dot(i, C.xxx);

                    vec3 g = step(x0.yzx, x0.xyz);
                    vec3 l = 1.0 - g;
                    vec3 i1 = min(g.xyz, l.zxy);
                    vec3 i2 = max(g.xyz, l.zxy);

                    vec3 x1 = x0 - i1 + C.xxx;
                    vec3 x2 = x0 - i2 + C.yyy;
                    vec3 x3 = x0 - D.yyy;

                    i = mod289(i);
                    vec4 p = permute(permute(permute(
                        i.z + vec4(0.0, i1.z, i2.z, 1.0))
                        + i.y + vec4(0.0, i1.y, i2.y, 1.0))
                        + i.x + vec4(0.0, i1.x, i2.x, 1.0));

                    float n_ = 0.142857142857;
                    vec3 ns = n_ * D.wyz - D.xzx;

                    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);

                    vec4 x_ = floor(j * ns.z);
                    vec4 y_ = floor(j - 7.0 * x_);

                    vec4 x = x_ *ns.x + ns.yyyy;
                    vec4 y = y_ *ns.x + ns.yyyy;
                    vec4 h = 1.0 - abs(x) - abs(y);

                    vec4 b0 = vec4(x.xy, y.xy);
                    vec4 b1 = vec4(x.zw, y.zw);

                    vec4 s0 = floor(b0)*2.0 + 1.0;
                    vec4 s1 = floor(b1)*2.0 + 1.0;
                    vec4 sh = -step(h, vec4(0.0));

                    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;

                    vec3 p0 = vec3(a0.xy, h.x);
                    vec3 p1 = vec3(a0.zw, h.y);
                    vec3 p2 = vec3(a1.xy, h.z);
                    vec3 p3 = vec3(a1.zw, h.w);

                    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                    p0 *= norm.x;
                    p1 *= norm.y;
                    p2 *= norm.z;
                    p3 *= norm.w;

                    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                    m = m * m;
                    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
                }

                // Fractal Brownian Motion for sophisticated turbulence
                float fbm(vec3 p, float t) {
                    float value = 0.0;
                    float amplitude = 0.5;
                    float frequency = 1.0;

                    for(int i = 0; i < 6; i++) {
                        value += amplitude * snoise(p * frequency + vec3(0.0, t * 0.6, 0.0));
                        amplitude *= 0.5;
                        frequency *= 2.1;
                    }
                    return value;
                }

                // Curl noise for swirling motion
                vec3 curlNoise(vec3 p, float t) {
                    float e = 0.1;
                    float n1 = snoise(p + vec3(0.0, e, 0.0) + vec3(0.0, t, 0.0));
                    float n2 = snoise(p + vec3(0.0, -e, 0.0) + vec3(0.0, t, 0.0));
                    float n3 = snoise(p + vec3(e, 0.0, 0.0) + vec3(0.0, t, 0.0));
                    float n4 = snoise(p + vec3(-e, 0.0, 0.0) + vec3(0.0, t, 0.0));

                    return vec3(
                        (n1 - n2) / (2.0 * e),
                        0.0,
                        (n3 - n4) / (2.0 * e)
                    );
                }

                // Volumetric fire with ray-marching (FIRST WORKING VERSION)
                float volumetricFire(vec3 pos, float t) {
                    // Multi-octave turbulence
                    float noise = 0.0;
                    float amplitude = 1.0;
                    float frequency = 1.0;

                    for (int i = 0; i < 4; i++) {
                        noise += amplitude * snoise(pos * frequency + vec3(0.0, t * 0.5, 0.0));
                        amplitude *= 0.5;
                        frequency *= 2.0;
                    }

                    // Height-based density gradient (fire rises)
                    float heightGradient = 1.0 - smoothstep(-0.3, 0.8, pos.y);

                    // Combine noise and gradient
                    float density = noise * heightGradient;

                    // Add turbulence
                    density += snoise(pos * 3.0 + vec3(t * 0.3, t * 0.8, 0.0)) * 0.3;

                    return clamp(density, 0.0, 1.0);
                }

                // Cinema 4D color grading: black ‚Üí dark red ‚Üí orange ‚Üí yellow ‚Üí white
                vec3 temperatureToColor(float temp) {
                    vec3 color;
                    if (temp < 0.2) {
                        // Black to dark red
                        color = mix(vec3(0.0), vec3(0.3, 0.0, 0.0), temp * 5.0);
                    } else if (temp < 0.4) {
                        // Dark red to red
                        color = mix(vec3(0.3, 0.0, 0.0), vec3(0.9, 0.1, 0.0), (temp - 0.2) * 5.0);
                    } else if (temp < 0.6) {
                        // Red to orange
                        color = mix(vec3(0.9, 0.1, 0.0), vec3(1.0, 0.5, 0.0), (temp - 0.4) * 5.0);
                    } else if (temp < 0.8) {
                        // Orange to yellow
                        color = mix(vec3(1.0, 0.5, 0.0), vec3(1.0, 0.9, 0.3), (temp - 0.6) * 5.0);
                    } else {
                        // Yellow to white (hottest part)
                        color = mix(vec3(1.0, 0.9, 0.3), vec3(1.0, 1.0, 1.0), (temp - 0.8) * 5.0);
                    }

                    return color;
                }

                void main() {
                    vec3 pos = vPosition;
                    float t = time * 0.8;

                    // Calculate fire density
                    float density = volumetricFire(pos, t);

                    // Cinema 4D color grading
                    vec3 color = temperatureToColor(density);

                    // Apply intensity
                    float alpha = density * intensity;

                    gl_FragColor = vec4(color, alpha);
                }
            `
        };

        // Create fire geometry (torus covering both rings)
        // Outer ring at ringRadius, inner segments at ringRadius - 0.3
        // Position fire at midpoint to cover both
        const fireGeometry = new THREE.TorusGeometry(
            ringRadius - 0.15,  // Midpoint between outer and inner rings
            0.35,               // Large enough tube to cover both rings (0.3 gap + ring thickness)
            32,                 // Radial segments
            100                 // Tubular segments
        );

        const fireMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0.0 },
                intensity: { value: 0.0 }  // Start invisible
            },
            vertexShader: fireShaderCode.vertexShader,
            fragmentShader: fireShaderCode.fragmentShader,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            side: THREE.DoubleSide
        });

        const fireMesh = new THREE.Mesh(fireGeometry, fireMaterial);
        scene.add(fireMesh);

        // Fire activation state
        let fireActive = false;
        let fireIntensityTarget = 0.0;

        function activateFire() {
            fireActive = true;
            fireIntensityTarget = 1.0;
            console.log('üî• Fire activated');
        }

        function deactivateFire() {
            fireActive = false;
            fireIntensityTarget = 0.0;
            console.log('üí® Fire deactivated');
        }

        // Update fire in animation loop
        function updateFire(deltaTime) {
            // Smooth intensity transition
            const currentIntensity = fireMaterial.uniforms.intensity.value;
            fireMaterial.uniforms.intensity.value += (fireIntensityTarget - currentIntensity) * 0.05;

            // Update time for shader animation
            fireMaterial.uniforms.time.value += deltaTime * 0.001;
        }

        // Initialize post-processing after page load
        window.addEventListener('load', () => {
            setTimeout(() => {
                if (setupPostProcessing()) {
                    console.log('üé¨ Cinema 4D quality fire system ready');
                }
            }, 500);
        });

        // ========== END FIRE SYSTEM ==========

        // ========== WORKOUT SMOKE & STROBE SYSTEM ==========

        // Create smoke group
        const smokeGroup = new THREE.Group();
        smokeGroup.position.set(0, 0, 0);
        scene.add(smokeGroup);

        // Smoke tube geometry - same as ring
        const smokeGeometry = new THREE.TorusGeometry(
            ringRadius - 0.15,
            0.35,
            32,
            100
        );

        // White smoke shader with strobe effect
        const smokeShaderCode = {
            vertexShader: `
                varying vec2 vUv;
                varying vec3 vPosition;

                void main() {
                    vUv = uv;
                    vPosition = position;
                    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                }
            `,

            fragmentShader: `
                uniform float time;
                uniform float intensity;
                uniform float strobeIntensity;
                varying vec2 vUv;
                varying vec3 vPosition;

                // Simple noise function
                float noise(vec2 st) {
                    return fract(sin(dot(st.xy, vec2(12.9898, 78.233))) * 43758.5453123);
                }

                void main() {
                    // Smoke movement
                    vec2 smokeCoord = vUv * 3.0 + time * 0.3;
                    float smokePattern = noise(smokeCoord);
                    smokePattern += noise(smokeCoord * 2.0) * 0.5;
                    smokePattern += noise(smokeCoord * 4.0) * 0.25;
                    smokePattern /= 1.75;

                    // Vertical gradient
                    float vertical = smoothstep(0.0, 0.5, vUv.y) * smoothstep(1.0, 0.5, vUv.y);

                    // White smoke color
                    vec3 smokeColor = vec3(0.9, 0.9, 0.95);

                    // Apply strobe flash
                    smokeColor *= strobeIntensity;

                    // Final alpha
                    float alpha = smokePattern * vertical * intensity * 0.7;

                    gl_FragColor = vec4(smokeColor, alpha);
                }
            `
        };

        const smokeMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                intensity: { value: 0.0 },
                strobeIntensity: { value: 1.0 }
            },
            vertexShader: smokeShaderCode.vertexShader,
            fragmentShader: smokeShaderCode.fragmentShader,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        const smokeMesh = new THREE.Mesh(smokeGeometry, smokeMaterial);
        smokeGroup.add(smokeMesh);

        // Smoke state
        let smokeActive = false;
        let smokeIntensityTarget = 0.0;
        let strobeTime = 0;

        function activateSmoke() {
            smokeActive = true;
            smokeIntensityTarget = 1.0;
            console.log('üí® Workout smoke activated');
        }

        function deactivateSmoke() {
            smokeActive = false;
            smokeIntensityTarget = 0.0;
            console.log('üí® Workout smoke deactivated');
        }

        // Update smoke in animation loop
        function updateSmoke(deltaTime) {
            // Smooth intensity transition
            const currentIntensity = smokeMaterial.uniforms.intensity.value;
            smokeMaterial.uniforms.intensity.value += (smokeIntensityTarget - currentIntensity) * 0.05;

            if (smokeActive || currentIntensity > 0.01) {
                // Update time for smoke animation
                smokeMaterial.uniforms.time.value += deltaTime * 0.0005;

                // Strobe effect - random flashes
                strobeTime += deltaTime * 0.002;

                // Fast strobe pattern (workout intensity!)
                const strobePattern = Math.sin(strobeTime * 30.0) > 0.7 ? 2.0 : 0.3;
                smokeMaterial.uniforms.strobeIntensity.value = strobePattern;

                // Rotate smoke slightly
                smokeGroup.rotation.z += deltaTime * 0.0003;
            }
        }

        // ========== END WORKOUT SMOKE & STROBE SYSTEM ==========

        // ========== CHINESE EMOJI SYSTEM (Ming Dynasty) ==========

        let chineseEmojiInterval = null;
        let chineseEmojiActive = false;
        const chineseEmojis = [
            'üêâ', 'üêâ', 'üêâ', 'üêâ',  // Dragons (most frequent)
            'üê≤', 'üê≤', 'üê≤',        // More dragons
            'ü•¢', 'ü•¢',              // Chopsticks
            'üèÆ'                     // Lantern
        ];

        function createChineseEmoji() {
            const emoji = document.createElement('div');
            emoji.className = 'chinese-emoji';
            emoji.textContent = chineseEmojis[Math.floor(Math.random() * chineseEmojis.length)];

            // Random starting position on screen
            const startX = Math.random() * window.innerWidth;
            const startY = Math.random() * window.innerHeight;
            emoji.style.left = startX + 'px';
            emoji.style.top = startY + 'px';

            // Random movement direction
            const tx = (Math.random() - 0.5) * 400; // -200 to 200px
            const ty = (Math.random() - 0.5) * 400;
            const rotate = (Math.random() - 0.5) * 720; // -360 to 360deg

            emoji.style.setProperty('--tx', tx + 'px');
            emoji.style.setProperty('--ty', ty + 'px');
            emoji.style.setProperty('--rotate', rotate + 'deg');

            document.body.appendChild(emoji);

            // Remove after animation completes
            setTimeout(() => {
                emoji.remove();
            }, 3000);
        }

        function activateYellowWater() {
            if (chineseEmojiActive) return;
            chineseEmojiActive = true;

            // Create initial burst of emojis
            for (let i = 0; i < 8; i++) {
                setTimeout(() => createChineseEmoji(), i * 100);
            }

            // Continue creating emojis while active
            chineseEmojiInterval = setInterval(() => {
                createChineseEmoji();
            }, 400);

            console.log('üêâ Chinese emojis activated');
        }

        function deactivateYellowWater() {
            if (!chineseEmojiActive) return;
            chineseEmojiActive = false;

            if (chineseEmojiInterval) {
                clearInterval(chineseEmojiInterval);
                chineseEmojiInterval = null;
            }

            // Remove all existing emojis
            document.querySelectorAll('.chinese-emoji').forEach(emoji => {
                emoji.remove();
            });

            console.log('üêâ Chinese emojis deactivated');
        }

        function updateYellowWater(deltaTime) {
            // CSS animations handle movement, no manual updates needed
        }

        // ========== END CHINESE EMOJI SYSTEM ==========

        // ========== VIDEO BOWLING BALL SYSTEM ==========

        // Create bowling ball group
        const bowlingBallGroup = new THREE.Group();
        bowlingBallGroup.position.set(0, 0, 0);
        scene.add(bowlingBallGroup);

        const ballRadius = ringRadius * 0.6;

        // Create video element
        const video = document.createElement('video');
        video.src = '/bowling-ball.mp4';
        video.loop = true;
        video.muted = true;
        video.playsInline = true;
        video.crossOrigin = 'anonymous';

        // Create video texture
        const videoTexture = new THREE.VideoTexture(video);
        videoTexture.minFilter = THREE.LinearFilter;
        videoTexture.magFilter = THREE.LinearFilter;

        // Create bowling ball geometry and material
        const ballGeometry = new THREE.SphereGeometry(ballRadius, 128, 128);
        const ballMaterial = new THREE.MeshBasicMaterial({
            map: videoTexture,
            transparent: true,
            opacity: 0.0
        });
        const ballMesh = new THREE.Mesh(ballGeometry, ballMaterial);
        bowlingBallGroup.add(ballMesh);

        // Bowling ball state
        let bowlingBallActive = false;
        let bowlingBallOpacityTarget = 0.0;

        function activateBowlingBall() {
            bowlingBallActive = true;
            bowlingBallOpacityTarget = 1.0;
            video.play().catch(e => console.log('Video play failed:', e));
            console.log('üé≥ Bowling ball activated');
        }

        function deactivateBowlingBall() {
            bowlingBallActive = false;
            bowlingBallOpacityTarget = 0.0;
            video.pause();
            console.log('üé≥ Bowling ball deactivated');
        }

        // Update bowling ball in animation loop
        function updateBowlingBall(deltaTime) {
            // Smooth opacity transition
            const currentOpacity = ballMaterial.opacity;
            ballMaterial.opacity += (bowlingBallOpacityTarget - currentOpacity) * 0.05;

            // Slower, elegant bowling ball spin
            if (bowlingBallActive || currentOpacity > 0.01) {
                bowlingBallGroup.rotation.y += deltaTime * 0.0009;  // Main spin
                bowlingBallGroup.rotation.x += deltaTime * 0.0002; // Slight wobble
                bowlingBallGroup.rotation.z += deltaTime * 0.00015; // Extra realism
            }
        }

        // ========== END BOWLING BALL SYSTEM ==========

        // ========== KISS EMOJI SYSTEM (New Oldtimer) ==========

        let kissEmojiInterval = null;
        let kissEmojiActive = false;
        const kissEmojis = ['üíã', 'üòò', 'üíï', 'üíñ', 'üòç', 'ü•∞'];

        function createKissEmoji() {
            const emoji = document.createElement('div');
            emoji.className = 'kiss-emoji';
            emoji.textContent = kissEmojis[Math.floor(Math.random() * kissEmojis.length)];

            // Random starting position on screen
            const startX = Math.random() * window.innerWidth;
            const startY = Math.random() * window.innerHeight;
            emoji.style.left = startX + 'px';
            emoji.style.top = startY + 'px';

            // Random movement direction
            const tx = (Math.random() - 0.5) * 400; // -200 to 200px
            const ty = (Math.random() - 0.5) * 400;
            const rotate = (Math.random() - 0.5) * 720; // -360 to 360deg

            emoji.style.setProperty('--tx', tx + 'px');
            emoji.style.setProperty('--ty', ty + 'px');
            emoji.style.setProperty('--rotate', rotate + 'deg');

            document.body.appendChild(emoji);

            // Remove after animation completes
            setTimeout(() => {
                emoji.remove();
            }, 3000);
        }

        function activateKissEmojis() {
            if (kissEmojiActive) return;
            kissEmojiActive = true;

            // Create initial burst of emojis
            for (let i = 0; i < 8; i++) {
                setTimeout(() => createKissEmoji(), i * 100);
            }

            // Continue creating emojis while active
            kissEmojiInterval = setInterval(() => {
                createKissEmoji();
            }, 400);

            console.log('üíã Kiss emojis activated');
        }

        function deactivateKissEmojis() {
            if (!kissEmojiActive) return;
            kissEmojiActive = false;

            if (kissEmojiInterval) {
                clearInterval(kissEmojiInterval);
                kissEmojiInterval = null;
            }

            // Remove all existing emojis
            document.querySelectorAll('.kiss-emoji').forEach(emoji => {
                emoji.remove();
            });

            console.log('üíã Kiss emojis deactivated');
        }

        // ========== END KISS EMOJI SYSTEM ==========

        // ========== BRUNCH PLATE SYSTEM (HTML overlay) ==========

        // Create brunch plate element
        const brunchPattern = document.createElement('img');
        brunchPattern.src = '/brunch-plate.png';

        // Size to be as large as possible without fork/spoon leaving frame - centered behind ring
        const isMobile = window.innerWidth < 768;
        const patternSize = isMobile ? '90vw' : '80vw'; // Much larger, full width basically

        brunchPattern.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: ${patternSize};
            max-width: 1200px;
            height: auto;
            object-fit: contain;
            opacity: 0;
            pointer-events: none;
            z-index: 0;
            transition: opacity 0.5s ease;
        `;

        document.body.appendChild(brunchPattern);

        // Brunch state
        let brunchActive = false;

        function activateBrunchPlate() {
            brunchActive = true;
            brunchPattern.style.opacity = '1';
            document.querySelector('.ring-overlay').classList.add('brunch-active');
            console.log('‚òï Brunch pattern activated');
        }

        function deactivateBrunchPlate() {
            brunchActive = false;
            brunchPattern.style.opacity = '0';
            document.querySelector('.ring-overlay').classList.remove('brunch-active');
            console.log('‚òï Brunch pattern deactivated');
        }

        // Update brunch animation (static image)
        function updateBrunchPlate(deltaTime) {
            // Static image - no animation needed
        }

        // ========== END BRUNCH PLATE SYSTEM ==========

        // ========== SCULPTURE BACKGROUND (Gem√§ldegalerie) ==========

        function activateSculpture() {
            document.body.classList.add('sculpture-active');
            console.log('üóø Classical sculpture background activated');
        }

        function deactivateSculpture() {
            document.body.classList.remove('sculpture-active');
            console.log('üóø Classical sculpture background deactivated');
        }

        // ========== END SCULPTURE BACKGROUND ==========

        // Interaction
        let isDragging = false;
        let previousMouseX = 0;
        let rotationVelocity = 0;
        let currentActive = null;

        const raycaster = new THREE.Raycaster();
        raycaster.params.Mesh.threshold = 0.2; // Increase hit detection threshold
        const mouse = new THREE.Vector2();

        function onPointerDown(e) {
            isDragging = true;
            container.classList.add('dragging');
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            previousMouseX = clientX;
            rotationVelocity = 0;
        }

        function onPointerMove(e) {
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;

            mouse.x = (clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(clientY / window.innerHeight) * 2 + 1;

            if (isDragging) {
                const deltaX = clientX - previousMouseX;
                rotationVelocity = deltaX * 0.01;
                previousMouseX = clientX;
            }
        }

        function onPointerUp() {
            isDragging = false;
            container.classList.remove('dragging');
        }

        function checkIntersections() {
            raycaster.setFromCamera(mouse, camera);

            // Check segments AND markers (entire slice is touchable)
            const allObjects = [];

            // Add all segments
            segments.forEach(s => allObjects.push(s));

            // Add markers and their children (hit areas)
            markers.forEach(m => {
                allObjects.push(m);
                m.children.forEach(child => allObjects.push(child));
            });

            const intersects = raycaster.intersectObjects(allObjects);

            if (intersects.length > 0) {
                const index = intersects[0].object.userData.index;
                if (index !== undefined) {
                    activateEvent(index);
                }
            } else if (!isDragging) {
                deactivateEvent();
            }
        }

        function activateEvent(index) {
            if (currentActive === index) return;

            // Deactivate previous
            if (currentActive !== null) {
                gsap.to(segments[currentActive].material, {
                    emissiveIntensity: 0,
                    duration: 0.5
                });
                gsap.to(markers[currentActive].scale, {
                    x: 1, y: 1, z: 1,
                    duration: 0.4,
                    ease: 'power2.out'
                });
                gsap.to(markers[currentActive].material, {
                    emissiveIntensity: 0.2,
                    duration: 0.4
                });

                // Deactivate bowling ball when switching away from Bowling
                if (currentActive === 0) {
                    deactivateBowlingBall();
                }

                // Deactivate kiss emojis when switching away from New Oldtimer
                if (currentActive === 1) {
                    deactivateKissEmojis();
                }

                // Deactivate brunch plate when switching away from Brunch
                if (currentActive === 2) {
                    deactivateBrunchPlate();
                }

                // Deactivate sculpture when switching away from Gem√§ldegalerie
                if (currentActive === 3) {
                    deactivateSculpture();
                }

                // Deactivate smoke when switching away from Workout
                if (currentActive === 4) {
                    deactivateSmoke();
                }

                // Deactivate yellow water when switching away from Dinner
                if (currentActive === 5) {
                    deactivateYellowWater();
                }

                // Deactivate fire when switching away from Victoria Bar
                if (currentActive === 6) {
                    deactivateFire();
                }
            }

            currentActive = index;
            const event = events[index];

            // Activate segment
            gsap.to(segments[index].material, {
                emissiveIntensity: 0.6,
                duration: 0.6,
                ease: 'power2.out'
            });

            // Scale marker
            gsap.to(markers[index].scale, {
                x: 1.5, y: 1.5, z: 1.5,
                duration: 0.5,
                ease: 'elastic.out(1, 0.5)'
            });

            gsap.to(markers[index].material, {
                emissiveIntensity: 0.8,
                duration: 0.4
            });

            // Update center info with GSAP
            const centerInfo = document.getElementById('centerInfo');
            const centerTime = document.getElementById('centerTime');
            const centerEvent = document.getElementById('centerEvent');
            const centerDate = document.getElementById('centerDate');
            const centerLocation = document.getElementById('centerLocation');

            // Fade out current
            gsap.to(centerInfo, {
                opacity: 0,
                duration: 0.2,
                onComplete: () => {
                    // Update content - line break between title and date
                    centerEvent.textContent = event.title;
                    centerDate.textContent = event.date;
                    centerTime.textContent = event.time;
                    centerLocation.textContent = event.location;

                    // Fade in new
                    centerInfo.classList.add('show');
                    gsap.to(centerInfo, {
                        opacity: 1,
                        duration: 0.5,
                        ease: 'power2.out'
                    });

                    gsap.fromTo(centerTime,
                        { scale: 0.9, opacity: 0 },
                        { scale: 1, opacity: 1, duration: 0.6, ease: 'back.out(1.7)' }
                    );
                }
            });

            // Update RSVP button - show modal
            document.getElementById('rsvpButton').onclick = (e) => {
                e.stopPropagation();
                openRSVPModal(event);
            };

            // Activate bowling ball ONLY for Bowling event (index 0)
            if (index === 0) {
                activateBowlingBall();
            }

            // Activate kiss emojis for New Oldtimer event (index 1)
            if (index === 1) {
                activateKissEmojis();
            }

            // Activate brunch plate for Brunch event (index 2)
            if (index === 2) {
                activateBrunchPlate();
            }

            // Activate sculpture for Gem√§ldegalerie event (index 3)
            if (index === 3) {
                activateSculpture();
            }

            // Activate smoke and strobe for Workout event (index 4)
            if (index === 4) {
                activateSmoke();
            }

            // Activate yellow water flow for Dinner event (index 5)
            if (index === 5) {
                activateYellowWater();
            }

            // Activate fire for Drinks event (index 6)
            if (index === 6) {
                activateFire();
            }

            // Haptic
            if (navigator.vibrate) navigator.vibrate(10);
        }

        function deactivateEvent() {
            if (currentActive === null) return;

            gsap.to(segments[currentActive].material, {
                emissiveIntensity: 0,
                duration: 0.5
            });

            gsap.to(markers[currentActive].scale, {
                x: 1, y: 1, z: 1,
                duration: 0.4,
                ease: 'power2.out'
            });

            gsap.to(markers[currentActive].material, {
                emissiveIntensity: 0.2,
                duration: 0.4
            });

            gsap.to('#centerInfo', {
                opacity: 0,
                duration: 0.3,
                onComplete: () => {
                    document.getElementById('centerInfo').classList.remove('show');
                }
            });

            // Deactivate bowling ball if it was Bowling
            if (currentActive === 0) {
                deactivateBowlingBall();
            }

            // Deactivate kiss emojis if it was New Oldtimer
            if (currentActive === 1) {
                deactivateKissEmojis();
            }

            // Deactivate brunch plate if it was Brunch
            if (currentActive === 2) {
                deactivateBrunchPlate();
            }

            // Deactivate sculpture if it was Gem√§ldegalerie
            if (currentActive === 3) {
                deactivateSculpture();
            }

            // Deactivate smoke if it was Workout
            if (currentActive === 4) {
                deactivateSmoke();
            }

            // Deactivate yellow water if it was Dinner
            if (currentActive === 5) {
                deactivateYellowWater();
            }

            // Deactivate fire if it was Victoria Bar
            if (currentActive === 6) {
                deactivateFire();
            }

            currentActive = null;
        }

        // Event listeners
        container.addEventListener('mousedown', onPointerDown);
        container.addEventListener('mousemove', onPointerMove);
        container.addEventListener('mouseup', onPointerUp);
        container.addEventListener('touchstart', onPointerDown, { passive: true });
        container.addEventListener('touchmove', onPointerMove, { passive: true });
        container.addEventListener('touchend', onPointerUp);

        // Animation loop
        let lastTime = Date.now();

        function animate() {
            requestAnimationFrame(animate);

            const currentTime = Date.now();
            const deltaTime = currentTime - lastTime;
            lastTime = currentTime;

            if (!isDragging) {
                rotationVelocity *= 0.95;
            }

            ring.rotation.z += rotationVelocity;

            segments.forEach(segment => {
                segment.rotation.z += rotationVelocity;
            });

            markers.forEach(marker => {
                const currentAngle = Math.atan2(marker.position.y, marker.position.x);
                const newAngle = currentAngle + rotationVelocity;
                marker.position.x = Math.cos(newAngle) * ringRadius;
                marker.position.y = Math.sin(newAngle) * ringRadius;
            });

            if (!isDragging) {
                checkIntersections();
            }

            // Subtle pulse
            ring.scale.setScalar(1 + Math.sin(Date.now() * 0.0008) * 0.008);

            // Update fire
            updateFire(deltaTime);

            // Update smoke
            updateSmoke(deltaTime);

            // Update yellow water
            updateYellowWater(deltaTime);

            // Update brunch plate
            updateBrunchPlate(deltaTime);

            // Update bowling ball
            updateBowlingBall(deltaTime);

            // Render with bloom if available, otherwise use standard renderer
            if (composer) {
                composer.render();
            } else {
                renderer.render(scene, camera);
            }
        }

        // RSVP Modal functions
        let currentEventForRSVP = null;

        function openRSVPModal(event) {
            currentEventForRSVP = event;

            // Set title
            const titleElement = document.getElementById('modalEventTitle');
            titleElement.textContent = event.title;

            document.getElementById('modalEventTime').innerHTML = `${event.date}<br>${event.time}<br>${event.location}`;

            const modal = document.getElementById('rsvpModal');
            const content = document.querySelector('.rsvp-content');
            const time = document.getElementById('modalEventTime');
            const inputs = document.querySelectorAll('.rsvp-input');
            const buttons = document.querySelectorAll('.rsvp-submit, #addToGoogleCal, #addToAppleCal');

            // Reset states
            gsap.set(content, { scale: 0.8, opacity: 0 });
            gsap.set(titleElement, { y: 20, opacity: 0 });
            gsap.set(time, { y: 20, opacity: 0 });
            gsap.set(inputs, { y: 20, opacity: 0 });
            gsap.set(buttons, { y: 20, opacity: 0 });

            // Show modal
            modal.classList.add('show');

            // Simple but elegant entrance sequence
            const timeline = gsap.timeline();

            // Modal background fades in
            timeline.to(modal, {
                opacity: 1,
                duration: 0.3,
                ease: 'power2.out'
            })
            // Card pops in
            .to(content, {
                scale: 1,
                opacity: 1,
                duration: 0.5,
                ease: 'back.out(1.5)',
            }, '-=0.1')
            // Title slides up
            .to(titleElement, {
                y: 0,
                opacity: 1,
                duration: 0.4,
                ease: 'power3.out'
            }, '-=0.2')
            // Time slides up
            .to(time, {
                y: 0,
                opacity: 1,
                duration: 0.4,
                ease: 'power3.out'
            }, '-=0.2')
            // Inputs fade in
            .to(inputs, {
                y: 0,
                opacity: 1,
                duration: 0.4,
                stagger: 0.1,
                ease: 'power2.out'
            }, '-=0.2')
            // Buttons fade in
            .to(buttons, {
                y: 0,
                opacity: 1,
                duration: 0.4,
                stagger: 0.08,
                ease: 'power2.out'
            }, '-=0.2');
        }

        function closeRSVPModal() {
            const modal = document.getElementById('rsvpModal');
            const content = document.querySelector('.rsvp-content');

            // Simple fade out
            gsap.to(content, {
                scale: 0.9,
                opacity: 0,
                duration: 0.25,
                ease: 'power2.in'
            });

            gsap.to(modal, {
                opacity: 0,
                duration: 0.25,
                ease: 'power2.in',
                onComplete: () => {
                    modal.classList.remove('show');
                    document.getElementById('rsvpName').value = '';
                    document.getElementById('rsvpPlusOnes').value = '';
                }
            });
        }


        // Generate ICS calendar file
        function generateCalendarFile(event) {
            // Parse date and time
            const dateStr = event.date; // "November 12" or "November 13"
            const timeStr = event.time; // "20:00"
            const endTimeStr = event.endTime; // "22:00"

            // Build full date string for 2025
            const month = dateStr.split(' ')[0];
            const day = parseInt(dateStr.split(' ')[1]);
            const year = 2025;

            // Parse times
            const [startHour, startMin] = timeStr.split(':').map(n => parseInt(n));
            const [endHour, endMin] = endTimeStr.split(':').map(n => parseInt(n));

            // Month mapping
            const monthMap = {
                'January': 0, 'February': 1, 'March': 2, 'April': 3,
                'May': 4, 'June': 5, 'July': 6, 'August': 7,
                'September': 8, 'October': 9, 'November': 10, 'December': 11
            };

            // Create Date objects in Berlin timezone (CET/CEST)
            // November is CET (UTC+1), no DST
            const startDate = new Date(Date.UTC(year, monthMap[month], day, startHour - 1, startMin, 0));
            const endDate = new Date(Date.UTC(year, monthMap[month], day, endHour - 1, endMin, 0));

            // Format dates for ICS (YYYYMMDDTHHMMSSZ format in UTC)
            function formatICSDate(date) {
                const year = date.getUTCFullYear();
                const month = String(date.getUTCMonth() + 1).padStart(2, '0');
                const day = String(date.getUTCDate()).padStart(2, '0');
                const hours = String(date.getUTCHours()).padStart(2, '0');
                const minutes = String(date.getUTCMinutes()).padStart(2, '0');
                const seconds = String(date.getUTCSeconds()).padStart(2, '0');
                return `${year}${month}${day}T${hours}${minutes}${seconds}Z`;
            }

            const startICS = formatICSDate(startDate);
            const endICS = formatICSDate(endDate);
            const now = formatICSDate(new Date());

            // Generate ICS content with proper formatting for Google Calendar
            const icsContent = [
                'BEGIN:VCALENDAR',
                'VERSION:2.0',
                'PRODID:-//40 Hours with Caspar//casparboehme.com//EN',
                'CALSCALE:GREGORIAN',
                'METHOD:PUBLISH',
                'X-WR-CALNAME:40 Hours with Caspar',
                'X-WR-TIMEZONE:Europe/Berlin',
                'BEGIN:VEVENT',
                `UID:${now}-${event.title.replace(/\s/g, '-').replace(/√§/g, 'a').replace(/√∂/g, 'o').replace(/√º/g, 'u')}@casparboehme.com`,
                `DTSTAMP:${now}`,
                `DTSTART:${startICS}`,
                `DTEND:${endICS}`,
                `SUMMARY:${event.title} - 40 Hours with Caspar`,
                `LOCATION:${event.address}`,
                `DESCRIPTION:Join us for ${event.title}!\\n\\nLocation: ${event.address}\\n\\nPart of Caspar's 40-hour birthday celebration November 12-13\\, 2025.`,
                'STATUS:CONFIRMED',
                'TRANSP:OPAQUE',
                'SEQUENCE:0',
                'BEGIN:VALARM',
                'TRIGGER:-PT30M',
                `DESCRIPTION:${event.title} in 30 minutes`,
                'ACTION:DISPLAY',
                'END:VALARM',
                'END:VEVENT',
                'END:VCALENDAR'
            ].join('\r\n');

            return icsContent;
        }

        function downloadCalendarFile() {
            if (!currentEventForRSVP) return;

            const icsContent = generateCalendarFile(currentEventForRSVP);
            const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = `40-hours-caspar-${currentEventForRSVP.title.replace(/\s/g, '-').toLowerCase()}.ics`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            console.log('üìÖ Calendar file downloaded:', currentEventForRSVP.title);
        }

        function addToGoogleCalendar() {
            if (!currentEventForRSVP) return;

            const event = currentEventForRSVP;

            // Parse date and time for Google Calendar URL
            const dateStr = event.date;
            const month = dateStr.split(' ')[0];
            const day = parseInt(dateStr.split(' ')[1]);
            const year = 2025;

            const [startHour, startMin] = event.time.split(':').map(n => parseInt(n));
            const [endHour, endMin] = event.endTime.split(':').map(n => parseInt(n));

            const monthMap = {
                'January': 0, 'February': 1, 'March': 2, 'April': 3,
                'May': 4, 'June': 5, 'July': 6, 'August': 7,
                'September': 8, 'October': 9, 'November': 10, 'December': 11
            };

            // Create dates in Berlin timezone (UTC+1 for November)
            const startDate = new Date(Date.UTC(year, monthMap[month], day, startHour - 1, startMin, 0));
            const endDate = new Date(Date.UTC(year, monthMap[month], day, endHour - 1, endMin, 0));

            // Format for Google Calendar (YYYYMMDDTHHMMSSZ)
            function formatGoogleDate(date) {
                const year = date.getUTCFullYear();
                const month = String(date.getUTCMonth() + 1).padStart(2, '0');
                const day = String(date.getUTCDate()).padStart(2, '0');
                const hours = String(date.getUTCHours()).padStart(2, '0');
                const minutes = String(date.getUTCMinutes()).padStart(2, '0');
                const seconds = String(date.getUTCSeconds()).padStart(2, '0');
                return `${year}${month}${day}T${hours}${minutes}${seconds}Z`;
            }

            const startFormatted = formatGoogleDate(startDate);
            const endFormatted = formatGoogleDate(endDate);

            // Build Google Calendar URL
            const title = encodeURIComponent(`${event.title} - 40 Hours with Caspar`);
            const dates = `${startFormatted}/${endFormatted}`;
            const details = encodeURIComponent(`Join us for ${event.title}!\n\nLocation: ${event.address}\n\nPart of Caspar's 40-hour birthday celebration November 12-13, 2025.`);
            const location = encodeURIComponent(event.address);

            const googleCalendarUrl = `https://calendar.google.com/calendar/render?action=TEMPLATE&text=${title}&dates=${dates}&details=${details}&location=${location}`;

            // Open in new tab
            window.open(googleCalendarUrl, '_blank');

            console.log('üìÖ Opening Google Calendar for:', event.title);
        }

        function addToAppleCalendar() {
            if (!currentEventForRSVP) return;

            const icsContent = generateCalendarFile(currentEventForRSVP);
            const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
            const url = URL.createObjectURL(blob);

            // Open .ics file directly (will auto-open in Calendar app on Mac/iOS)
            window.location.href = url;

            // Clean up after a delay
            setTimeout(() => {
                URL.revokeObjectURL(url);
            }, 100);

            console.log('üìÖ Opening Apple Calendar for:', currentEventForRSVP.title);
        }

        async function submitRSVP() {
            const name = document.getElementById('rsvpName').value.trim();
            const plusOnes = document.getElementById('rsvpPlusOnes').value.trim();

            if (!name) {
                alert('Please enter your name');
                return;
            }

            // Create event ID from title (e.g., "bowling", "brunch")
            const eventId = currentEventForRSVP.title.toLowerCase().replace(/\s+/g, '-');

            try {
                // Send RSVP to backend
                const response = await fetch('/api/rsvps', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        eventId: eventId,
                        name: name,
                        plusOnes: parseInt(plusOnes) || 0
                    })
                });

                const data = await response.json();

                if (data.success) {
                    console.log('‚úÖ RSVP Saved to Database:', {
                        id: data.id,
                        event: currentEventForRSVP.title,
                        name: name,
                        plusOnes: plusOnes,
                        timestamp: new Date().toISOString()
                    });


                    // Download calendar file automatically on RSVP
                    downloadCalendarFile();

                    // Animate success message
                    const submitBtn = document.getElementById('rsvpSubmit');
                    const originalText = submitBtn.textContent;
                    submitBtn.textContent = '‚úì LOCKED IN';
                    submitBtn.style.background = '#FFFFFF';
                    submitBtn.style.color = '#000000';

                    // Keep modal open for 4 seconds so user can click calendar buttons
                    setTimeout(() => {
                        closeRSVPModal();
                        // Reset button
                        setTimeout(() => {
                            submitBtn.textContent = originalText;
                            submitBtn.style.background = '';
                            submitBtn.style.color = '';
                        }, 500);
                    }, 4000);
                } else {
                    throw new Error(data.error || 'Failed to save RSVP');
                }
            } catch (error) {
                console.error('‚ùå RSVP Error:', error);
                alert('Sorry, there was an error saving your RSVP. Please try again.');
            }
        }

        // RSVP Modal event listeners
        document.getElementById('rsvpSubmit').addEventListener('click', submitRSVP);
        document.getElementById('addToGoogleCal').addEventListener('click', addToGoogleCalendar);
        document.getElementById('addToAppleCal').addEventListener('click', addToAppleCalendar);

        document.getElementById('rsvpForm').addEventListener('submit', (e) => {
            e.preventDefault();
            submitRSVP();
        });

        // Close modal on escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && document.getElementById('rsvpModal').classList.contains('show')) {
                closeRSVPModal();
            }
        });

        // Handle resize - recalculate for ANY screen size
        window.addEventListener('resize', () => {
            const newRingSize = calculateRingSize();
            camera.position.z = newRingSize.cameraZ;
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);

            // Update composer size if available
            if (composer) {
                composer.setSize(window.innerWidth, window.innerHeight);
            }

            // Update brunch plate size
            const isMobileNow = window.innerWidth < 768;
            const newPatternSize = isMobileNow ? '90vw' : '80vw';
            brunchPattern.style.width = newPatternSize;
        });

        animate();
        document.addEventListener('contextmenu', e => e.preventDefault());
    </script>
</body>
</html>
